package com.family_tree.familytree;

import java.io.IOException;
import java.util.*;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.stream.Collectors;
import com.family_tree.enums.Gender;
import com.family_tree.enums.PrivacySetting;
import com.family_tree.enums.SuggestionStatus;
import com.family_tree.enums.RelationshipType;
import com.family_tree.enums.Role;
import com.family_tree.enums.Status;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController {

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    @Autowired
    private FamilyTreeRepository familyTreeRepository;

    @Autowired
    private FamilyMemberRepository familyMemberRepository;

    @Autowired
    private SuggestEditRepository suggestEditRepository;

    @Autowired
    private SuggestEditService suggestedEditService;

    @Autowired
    private RelationshipRepository relationshipRepository;

    @Autowired
    private AttachmentRepository attachmentRepository;

    @Autowired
    private CollaborationRepository collaborationRepository;

    @Autowired
    private ExportConfigurationRepository exportConfigurationRepository;

    @Autowired
    private ExportService exportService;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private FamilyTreeService familyTreeService;

    @Autowired
    private MergeRequestRepository mergeRequestRepository;

    // User-related methods -----------------------------------------------------
    @PostMapping(path="/addUser") //Map only post requests
    public @ResponseBody String addNewUser (@RequestParam String username,
                                            @RequestParam String emailAddress) {
        // Ensure username and email are not left empty
        if (username == null || username.isEmpty() || emailAddress == null || emailAddress.isEmpty()) {
            return "Username and Email Address are required.";
        }

        // Check for existing username or email
        if (userRepository.existsByEmail(emailAddress)) {
            return "Email already exists";
        }
        if (userRepository.existsByUsername(username)) {
            return "Username already exists";
        }

        try {
            // Create and add user to the database
            User user = new User();
            user.setUsername(username);
            user.setEmail(emailAddress);
            userRepository.save(user);
            return "User Saved Successfully";
        } catch (Exception e) {
            return "Error saving user: " + e.getMessage();
        }
    }

    @PostMapping("/updateUser")
    public @ResponseBody String updateUser(@RequestParam Integer userId,
                                           @RequestParam(required = false) String username,
                                           @RequestParam(required = false) String email) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        if (username != null && !user.getUsername().equals(username)) {
            if (userRepository.existsByUsername(username)) {
                return "Username already exists";
            }
            user.setUsername(username);
        }

        if (email != null && !user.getEmail().equals(email)) {
            if (userRepository.existsByEmail(email)) {
                return "Email already exists";
            }
            user.setEmail(email);
        }

        userRepository.save(user);
        return "User updated successfully";
    }

    //Get user by id
    @GetMapping("/getUserById")
    public @ResponseBody Optional<User> getUserById(@RequestParam Integer userId) {
        return userRepository.findById(userId);
    }

    //Search users by email or username
    @GetMapping("/searchUsers")
    public @ResponseBody List<User> searchUsers(@RequestParam String keyword) {
        return userRepository.searchUsersByKeyword(keyword);
    }

    //Get user by username
    @GetMapping("/getUserByUsername")
    public @ResponseBody Optional<User> getUserByUsername(@RequestParam String username) {
        return userRepository.findByUsername(username);
    }

    @GetMapping(path="/allUsers")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    @PostMapping("/deleteUser")
    @Transactional // Ensures all deletions succeed or rollback together
    public @ResponseBody String deleteUser(@RequestParam Integer userId) {
        try {

            // Delete family trees owned by this user
            familyTreeRepository.deleteByOwnerId(userId);

            // Remove any family members added by this user or where the user is the "owner"
            familyMemberRepository.deleteByOwnerOrAddedBy(userId);

            // Remove any suggested edits made by this user
            suggestEditRepository.deleteBySuggestedById(userId);

            // Remove any attachments uploaded by this user
            attachmentRepository.deleteByUploadedById(userId);

            // Remove any collaborations where this user is involved
            collaborationRepository.deleteByUserId(userId);

            // Finally, delete the user itself
            userRepository.deleteById(userId);

            return "User and all associated records deleted successfully";
        } catch (Exception e) {
            return "Error deleting user and associated records: " + e.getMessage();
        }
    }

    @PostMapping("/createFamilyTree")
    public @ResponseBody Map<String, Object> addFamilyTree(@RequestParam String treeName,
                                                           @RequestParam PrivacySetting privacySetting,
                                                           @RequestParam Integer userId) {
        Map<String, Object> response = new HashMap<>();
        try {
            if (treeName == null || treeName.isEmpty()) {
                response.put("error", "Tree name is required.");
                return response;
            }
            if (privacySetting == null) {
                response.put("error", "Privacy setting is required.");
                return response;
            }
            if (userId == null) {
                response.put("error", "User ID is required.");
                return response;
            }

            // Find the user that will own the tree
            User owner = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Create and save the family tree
            FamilyTree familyTree = new FamilyTree();
            familyTree.setTreeName(treeName);
            familyTree.setPrivacySetting(privacySetting);
            familyTree.setOwner(owner);
            familyTree = familyTreeRepository.save(familyTree);

            // Add the owner as a collaborator with the Owner role
            Collaboration collaboration = new Collaboration();
            collaboration.setFamilyTree(familyTree);
            collaboration.setUser(owner);
            collaboration.setRole(Role.Owner);
            collaboration.setStatus(Status.Accepted); // Automatically accepted for owner
            collaborationRepository.save(collaboration);

            // Return the newly created tree ID
            response.put("success", "Family Tree Saved Successfully");
            response.put("treeId", familyTree.getId());
            return response;
        } catch (Exception e) {
            response.put("error", "Error saving family tree: " + e.getMessage());
            return response;
        }
    }



    //Update family tree and privacy settings (user decides to edit tree information)
    @PostMapping("/updateFamilyTree")
    public @ResponseBody String updateFamilyTree(@RequestParam Integer treeId,
                                                 @RequestParam(required = false) String treeName,
                                                 @RequestParam(required = false) PrivacySetting privacySetting) {
        try {
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));

            if (treeName != null && !treeName.isEmpty()) {
                familyTree.setTreeName(treeName);
            }
            if (privacySetting != null) {
                familyTree.setPrivacySetting(privacySetting);
            }

            familyTreeRepository.save(familyTree);
            return "Family Tree Updated Successfully";
        } catch (Exception e) {
            return "Error updating family tree: " + e.getMessage();
        }
    }


    //Method for getting all family trees for an owner
    @GetMapping("/getUserFamilyTrees")
    public @ResponseBody List<FamilyTree> getUserFamilyTrees(@RequestParam Integer userId) {
        return familyTreeRepository.findByOwner_Id(userId);
    }

    //Method for getting tree by treeId
    @GetMapping("/getFamilyTree")
    public @ResponseBody FamilyTree getFamilyTree(@RequestParam Integer treeId) {
        return familyTreeRepository.findById(treeId)
                .orElseThrow(() -> new RuntimeException("Family tree not found"));
    }

    //Method to find all public trees
    @GetMapping("/getPublicTrees")
    public @ResponseBody Map<String, Object> getPublicTrees() {
        Map<String, Object> response = new HashMap<>();
        try {
            List<FamilyTree> publicTrees = familyTreeRepository.findByPrivacySetting(PrivacySetting.Public);

            // Check if there are no public trees available
            if (publicTrees.isEmpty()) {
                response.put("status", "success");
                response.put("message", "No public family trees available at this time.");
                response.put("data", Collections.emptyList());
                return response;
            }

            // Prepare the response data
            List<Map<String, Object>> treeData = new ArrayList<>();
            for (FamilyTree tree : publicTrees) {
                Map<String, Object> treeInfo = new HashMap<>();
                treeInfo.put("treeId", tree.getId());
                treeInfo.put("treeName", tree.getTreeName());
                treeInfo.put("ownerUsername", tree.getOwner().getUsername());
                // Add more public fields if needed, while excluding sensitive information
                treeData.add(treeInfo);
            }

            // Retrieval of public trees yields successful
            response.put("status", "success");
            response.put("message", "Public family trees retrieved successfully.");
            response.put("data", treeData);
            return response;

        } catch (Exception e) {
            // Handle any unexpected errors
            response.put("status", "error");
            response.put("message", "An error occurred while retrieving public family trees: " + e.getMessage());
            response.put("data", Collections.emptyList());
            return response;
        }
    }

    //Delete family tree by ID
    @PostMapping("/deleteFamilyTree")
    @Transactional // Ensures all deletions succeed or roll back together
    public @ResponseBody String deleteFamilyTree(@RequestParam Integer treeId) {
        try {
            // Delete all family members associated with this tree
            familyMemberRepository.deleteByTreeId(treeId);

            // Delete all relationships associated with this tree
            relationshipRepository.deleteByTreeId(treeId);

            // Delete all collaborations associated with this tree
            collaborationRepository.deleteByTreeId(treeId);

            // Delete the family tree itself
            familyTreeRepository.deleteById(treeId);

            return "Family Tree and all associated records deleted successfully";
        } catch (Exception e) {
            return "Error deleting family tree and associated records: " + e.getMessage();
        }
    }

    // Add a new family member with optional pid, mid, and fid fields
    @PostMapping("/addFamilyMember")
    public @ResponseBody Map<String, Object> addFamilyMember(@RequestParam String name,
                                                             @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date birthdate,
                                                             @RequestParam Gender gender,
                                                             @RequestParam Integer userId,
                                                             @RequestParam Integer treeId,
                                                             @RequestParam Integer addedById,
                                                             @RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date deathdate,
                                                             @RequestParam(required = false) String additionalInfo,
                                                             @RequestParam(required = false) Integer pid,
                                                             @RequestParam(required = false) Integer mid,
                                                             @RequestParam(required = false) Integer fid) {
        Map<String, Object> response = new HashMap<>();

        // Ensure required fields are not left empty
        if (name == null || name.isEmpty()) {
            response.put("status", "error");
            response.put("message", "Name is required.");
            return response;
        }
        if (birthdate == null) {
            response.put("status", "error");
            response.put("message", "Birthdate is required.");
            return response;
        }
        if (gender == null) {
            response.put("status", "error");
            response.put("message", "Gender is required.");
            return response;
        }
        if (userId == null) {
            response.put("status", "error");
            response.put("message", "User ID is required.");
            return response;
        }
        if (treeId == null) {
            response.put("status", "error");
            response.put("message", "Tree ID is required.");
            return response;
        }
        if (addedById == null) {
            response.put("status", "error");
            response.put("message", "Added By ID is required.");
            return response;
        }

        try {
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));

            User owner = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("Owner not found"));

            User addedBy = userRepository.findById(addedById)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            FamilyMember familyMember = new FamilyMember();
            familyMember.setName(name);
            familyMember.setBirthdate(birthdate);
            familyMember.setDeathdate(deathdate);
            familyMember.setGender(gender);
            familyMember.setFamilyTree(familyTree);
            familyMember.setOwner(owner);
            familyMember.setAddedBy(addedBy);
            familyMember.setAdditionalInfo(additionalInfo);
            familyMember.setPid(pid);
            familyMember.setMid(mid);
            familyMember.setFid(fid);

            familyMember = familyMemberRepository.save(familyMember); // Save and get the persisted entity

            // Build the success response
            response.put("status", "success");
            response.put("message", "Family Member Saved Successfully");
            response.put("memberId", familyMember.getMemberId()); // Include the memberId in the response

            return response;
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error saving family member: " + e.getMessage());
            return response;
        }
    }

    // Edit an existing family member, including pid, mid, and fid fields
    @PostMapping("/editFamilyMember")
    public @ResponseBody String editFamilyMember(@RequestParam Integer memberId,
                                                 @RequestParam(required = false) String name,
                                                 @RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date birthdate,
                                                 @RequestParam(required = false) Gender gender,
                                                 @RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date deathdate,
                                                 @RequestParam(required = false) String additionalInfo,
                                                 @RequestParam(required = false) Integer pid,
                                                 @RequestParam(required = false) Integer mid,
                                                 @RequestParam(required = false) Integer fid) {
        try {
            FamilyMember familyMember = familyMemberRepository.findById(memberId)
                    .orElseThrow(() -> new RuntimeException("Family member not found"));

            if (name != null && !name.isEmpty()) {
                familyMember.setName(name);
            }
            if (birthdate != null) {
                familyMember.setBirthdate(birthdate);
            }
            if (gender != null) {
                familyMember.setGender(gender);
            }
            if (deathdate != null) {
                familyMember.setDeathdate(deathdate);
            }
            if (additionalInfo != null && !additionalInfo.isEmpty()) {
                familyMember.setAdditionalInfo(additionalInfo);
            }
            if (pid != null) {
                familyMember.setPid(pid);
            }
            if (mid != null) {
                familyMember.setMid(mid);
            }
            if (fid != null) {
                familyMember.setFid(fid);
            }

            familyMemberRepository.save(familyMember);
            return "Family Member Updated Successfully";
        } catch (Exception e) {
            return "Error updating family member: " + e.getMessage();
        }
    }

    // Retrieve all family members in a tree, including their relationships
    @GetMapping("/getFamilyMembersInTree")
    public @ResponseBody List<FamilyMember> getFamilyMembersInTree(@RequestParam Integer treeId) {
        return familyMemberRepository.findByFamilyTreeId(treeId);
    }

    // Delete a family member, ensuring relationships are cleared
    @PostMapping("/deleteFamilyMember")
    @Transactional
    public @ResponseBody String deleteFamilyMember(@RequestParam Integer memberId) {
        try {
            relationshipRepository.deleteByMemberId(memberId);
            familyMemberRepository.deleteById(memberId);
            return "Family Member and all associated records deleted successfully";
        } catch (Exception e) {
            return "Error deleting family member and associated records: " + e.getMessage();
        }
    }


    
    // Relationship-related methods ------------------------------------------------------------------
    @PostMapping("/addRelationship")
    public @ResponseBody String addRelationship(@RequestParam Integer treeId,
                                                @RequestParam Integer member1Id,
                                                @RequestParam Integer member2Id,
                                                @RequestParam RelationshipType relationship) {
        //Ensure required fields are not left empty
        if (treeId == null) {
            return "Tree ID is required.";
        }
        if (member1Id == null) {
            return "Member 1 ID is required.";
        }
        if (member2Id == null) {
            return "Member 2 ID is required.";
        }
        if (relationship == null) {
            return "Relationship type is required.";
        }

        try {
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));

            FamilyMember member1 = familyMemberRepository.findById(member1Id)
                    .orElseThrow(() -> new RuntimeException("Family member 1 not found"));

            FamilyMember member2 = familyMemberRepository.findById(member2Id)
                    .orElseThrow(() -> new RuntimeException("Family member 2 not found"));

            //Add relationship to the database
            Relationship rel = new Relationship(); //rel refers to relationship
            rel.setFamilyTree(familyTree);
            rel.setMember1(member1);
            rel.setMember2(member2);
            rel.setRelationship(relationship);

            relationshipRepository.save(rel);
            return "Relationship Saved Successfully";
        } catch (Exception e) {
            return "Error saving relationship: " + e.getMessage();
        }
    }

    //Method for updating relationship
    @PostMapping("/updateRelationship")
    public @ResponseBody String updateRelationship(
            @RequestParam Integer relationshipId,
            @RequestParam(required = false) Integer member1Id,
            @RequestParam(required = false) Integer member2Id,
            @RequestParam(required = false) RelationshipType relationshipType) {
        try {
            Relationship relationship = relationshipRepository.findById(relationshipId)
                    .orElseThrow(() -> new RuntimeException("Relationship not found"));

            // Update member1 if provided
            if (member1Id != null) {
                FamilyMember member1 = familyMemberRepository.findById(member1Id)
                        .orElseThrow(() -> new RuntimeException("Member 1 not found"));
                relationship.setMember1(member1);
            }

            // Update member2 if provided
            if (member2Id != null) {
                FamilyMember member2 = familyMemberRepository.findById(member2Id)
                        .orElseThrow(() -> new RuntimeException("Member 2 not found"));
                relationship.setMember2(member2);
            }

            // Update relationship type if provided
            if (relationshipType != null) {
                relationship.setRelationship(relationshipType);
            }

            relationshipRepository.save(relationship);
            return "Relationship Updated Successfully";
        } catch (Exception e) {
            return "Error updating relationship: " + e.getMessage();
        }
    }

    //Get relationships on a tree
    @GetMapping("/getRelationshipsForTree")
    public @ResponseBody List<Relationship> getRelationshipsForTree(@RequestParam Integer treeId) {
        try {
            return relationshipRepository.findByFamilyTreeId(treeId);
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving relationships for the tree: " + e.getMessage());
        }
    }

    //Delete relationships by a specific family member
    @PostMapping("/deleteRelationshipsByMember")
    @Transactional
    public @ResponseBody String deleteRelationshipsByMember(@RequestParam Integer memberId) {
        try {
            relationshipRepository.deleteByMemberId(memberId);
            return "Relationships for member deleted successfully.";
        } catch (Exception e) {
            return "Error deleting relationships for member: " + e.getMessage();
        }
    }

    //Attachment-related methods -----------------------------------------------------------------
    @PostMapping("/addAttachment")
    public @ResponseBody String addAttachment(
            @RequestParam Integer memberId,
            @RequestParam String typeOfFile,
            @RequestParam MultipartFile fileData, // MultipartFile to handle binary data upload
            @RequestParam Integer uploadedById) {
        //Ensure required fields are not left empty
        if (memberId == null) {
            return "Member ID is required.";
        }
        if (typeOfFile == null || typeOfFile.isEmpty()) {
            return "Type of file is required.";
        }
        if (fileData == null || fileData.isEmpty()) {
            return "File data is required.";
        }
        if (uploadedById == null) {
            return "Uploaded By ID is required.";
        }

        try {
            // Find the family member to whom this attachment will be associated
            FamilyMember member = familyMemberRepository.findById(memberId)
                    .orElseThrow(() -> new RuntimeException("Family member not found"));
            // Find the user who uploaded this file
            User uploadedBy = userRepository.findById(uploadedById)
                    .orElseThrow(() -> new RuntimeException("Uploader not found"));
            // Create a new attachment
            Attachment attachment = new Attachment();
            attachment.setMember(member);
            attachment.setTypeOfFile(typeOfFile);
            attachment.setFileData(fileData.getBytes());// Set the file data from the MultipartFile input
            attachment.setUploadedBy(uploadedBy);

            attachmentRepository.save(attachment);
            return "Attachment Saved Successfully";
        } catch (IOException e) {
            return "Error reading file data: " + e.getMessage();
        } catch (Exception e) {
            return "Error saving attachment: " + e.getMessage();
        }
    }

    // Method for retrieving attachments with Base64 encoding for a specific family member
    @GetMapping("/getAttachmentsForMember")
    public @ResponseBody List<Map<String, Object>> getAttachmentsForMember(@RequestParam Integer memberId) {
        List<Attachment> attachments = attachmentRepository.findByMember_MemberId(memberId);

        return attachments.stream().map(attachment -> {
            Map<String, Object> response = new HashMap<>();
            response.put("mediaId", attachment.getMediaId());
            response.put("typeOfFile", attachment.getTypeOfFile());

            // Convert binary data to Base64
            String base64Image = Base64.getEncoder().encodeToString(attachment.getFileData());
            response.put("fileData", "data:image/jpeg;base64," + base64Image); // Adjust MIME type as needed

            return response;
        }).collect(Collectors.toList());
    }

    //Get attachment by media id
    @GetMapping("/getAttachment")
    public @ResponseBody Map<String, Object> getAttachment(@RequestParam Integer mediaId) {
        try {
            Attachment attachment = attachmentRepository.findById(mediaId)
                    .orElseThrow(() -> new RuntimeException("Attachment not found"));

            Map<String, Object> response = new HashMap<>();
            response.put("mediaId", attachment.getMediaId());
            response.put("typeOfFile", attachment.getTypeOfFile());

            // Convert binary data to Base64 for sending over JSON
            String base64File = Base64.getEncoder().encodeToString(attachment.getFileData());
            response.put("fileData", "data:application/octet-stream;base64," + base64File);

            return response;
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving attachment: " + e.getMessage());
        }
    }

    // Update all attachments' details for a specific family member
    @PostMapping("/updateAttachmentsForMember")
    public @ResponseBody String updateAttachmentsForMember(
            @RequestParam Integer memberId,
            @RequestParam(required = false) String typeOfFile,
            @RequestParam(required = false) MultipartFile fileData) {
        try {
            List<Attachment> attachments = attachmentRepository.findByMember_MemberId(memberId);

            if (attachments.isEmpty()) {
                return "No attachments found for the given family member";
            }

            for (Attachment attachment : attachments) {
                if (typeOfFile != null && !typeOfFile.isEmpty()) {
                    attachment.setTypeOfFile(typeOfFile);
                }

                if (fileData != null && !fileData.isEmpty()) {
                    attachment.setFileData(fileData.getBytes());
                }

                attachmentRepository.save(attachment); // Save each updated attachment
            }

            return "Attachments Updated Successfully";
        } catch (IOException e) {
            return "Error reading file data: " + e.getMessage();
        } catch (Exception e) {
            return "Error updating attachments: " + e.getMessage();
        }
    }

    // Delete an attachment by mediaId
    @PostMapping("/deleteAttachment")
    public @ResponseBody String deleteAttachment(@RequestParam Integer mediaId) {
        try {
            attachmentRepository.deleteById(mediaId);
            return "Attachment Deleted Successfully";
        } catch (Exception e) {
            return "Error deleting attachment: " + e.getMessage();
        }
    }


    //Collaboration-related methods -----------------------------------------------------------------
    // Endpoint to add a collaboration directly with a specified status and role
    @PostMapping("/addCollaboration")
    public @ResponseBody String addCollaboration(@RequestParam Integer treeId,
                                                 @RequestParam Integer userId,
                                                 @RequestParam Role role,
                                                 @RequestParam Status status) {
        if (treeId == null) {
            return "Tree ID is required.";
        }
        if (userId == null) {
            return "User ID is required.";
        }
        if (role == null) {
            return "Role is required.";
        }
        if (status == null) {
            return "Status is required.";
        }

        try {
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            Collaboration collaboration = new Collaboration();
            collaboration.setFamilyTree(familyTree);
            collaboration.setUser(user);
            collaboration.setRole(role);
            collaboration.setStatus(status);

            collaborationRepository.save(collaboration);
            return "Collaboration Saved Successfully";
        } catch (Exception e) {
            return "Error saving collaboration: " + e.getMessage();
        }
    }

    // Endpoint to retrieve all collaborations
    @GetMapping("/allCollaborations")
    public @ResponseBody Iterable<Collaboration> getAllCollaborations() {
        return collaborationRepository.findAll();
    }


    // Modifying inviteCollaborator to send a notification when a user is invited
    @PostMapping("/collaborations/invite")
    public @ResponseBody String inviteCollaborator(@RequestParam Integer treeId,
                                                   @RequestParam Integer userId,
                                                   @RequestParam Role role) {
        try {
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Check if a pending or accepted collaboration already exists
            Optional<Collaboration> existingCollaboration = collaborationRepository
                    .findByFamilyTreeIdAndUserId(treeId, userId);

            if (existingCollaboration.isPresent() &&
                    (existingCollaboration.get().getStatus() == Status.Pending ||
                            existingCollaboration.get().getStatus() == Status.Accepted)) {
                return "User is already invited or a collaborator.";
            }

            Collaboration collaboration = new Collaboration();
            collaboration.setFamilyTree(familyTree);
            collaboration.setUser(user);
            collaboration.setRole(role);
            collaboration.setStatus(Status.Pending);

            collaborationRepository.save(collaboration);

            // Send notification to the invited user
            notificationService.createNotification(
                    user,
                    "You have been invited to collaborate on the tree '" + familyTree.getTreeName() + "'",
                    "/trees/" + treeId, treeId
            );

            return "Collaboration invitation sent successfully.";
        } catch (Exception e) {
            return "Error inviting collaborator: " + e.getMessage();
        }
    }

    // Endpoint for the invited user to accept the collaboration invite
    @PostMapping("/acceptCollaboration")
    public @ResponseBody String acceptCollaboration(@RequestParam Integer collaborationId) {
        try {
            Collaboration collaboration = collaborationRepository.findById(collaborationId)
                    .orElseThrow(() -> new RuntimeException("Collaboration not found"));
            User user = collaboration.getUser();
            FamilyTree tree = collaboration.getFamilyTree();
            Notification notification = notificationRepository.findByUser_IdAndTreeId_Id(user.getId(), tree.getId());
            notification.setRead(true);
            notificationRepository.save(notification);
            collaboration.setStatus(Status.Accepted);
            collaborationRepository.save(collaboration);
            return "Collaboration accepted.";
        } catch (Exception e) {
            return "Error accepting collaboration: " + e.getMessage();
        }
    }

    // Endpoint for the invited user to decline the collaboration invite
    @PostMapping("/declineCollaboration")
    public @ResponseBody String declineCollaboration(@RequestParam Integer collaborationId) {
        try {
            Collaboration collaboration = collaborationRepository.findById(collaborationId)
                    .orElseThrow(() -> new RuntimeException("Collaboration not found"));
            User user = collaboration.getUser();
            FamilyTree tree = collaboration.getFamilyTree();
            Notification notification = notificationRepository.findByUser_IdAndTreeId_Id(user.getId(), tree.getId());
            notification.setRead(true);
            notificationRepository.save(notification);
            collaboration.setStatus(Status.Declined);
            collaborationRepository.save(collaboration);
            return "Collaboration declined.";
        } catch (Exception e) {
            return "Error declining collaboration: " + e.getMessage();
        }
    }

    // Endpoint to update the role of a collaborator
    @PostMapping("/updateCollaborationRole")
    public @ResponseBody String updateCollaborationRole(@RequestParam Integer collaborationId,
                                                        @RequestParam Role newRole) {
        try {
            Collaboration collaboration = collaborationRepository.findById(collaborationId)
                    .orElseThrow(() -> new RuntimeException("Collaboration not found"));

            collaboration.setRole(newRole);
            collaborationRepository.save(collaboration);
            return "Collaboration role updated successfully.";
        } catch (Exception e) {
            return "Error updating collaboration role: " + e.getMessage();
        }
    }

    //Get collaboration by a collaboration id
    @GetMapping("/getCollaboration")
    public @ResponseBody Collaboration getCollaboration(@RequestParam Integer collaborationId) {
        try {
            return collaborationRepository.findById(collaborationId)
                    .orElseThrow(() -> new RuntimeException("Collaboration not found"));
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving collaboration: " + e.getMessage());
        }
    }

    //Get collaboration by a collaboration id
    @GetMapping("/getCollaborationByUser")
    public @ResponseBody List<Collaboration> getCollaborationByUser(@RequestParam Integer userId) {
        try {
            return collaborationRepository.findByUserId(userId);
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving collaborations: " + e.getMessage());
        }
    }

    // Endpoint to retrieve collaborations for a specific family tree
    @GetMapping("/getCollaborationsByTree")
    public @ResponseBody List<Collaboration> getCollaborationsByTree(@RequestParam Integer treeId) {
        return collaborationRepository.findByFamilyTreeId(treeId);
    }

    // Endpoint to remove a collaborator
    @PostMapping("/removeCollaborator")
    @Transactional // Ensure the operation is atomic
    public @ResponseBody String removeCollaborator(@RequestParam Integer collaborationId) {
        try {
            collaborationRepository.deleteById(collaborationId);
            return "Collaborator removed successfully.";
        } catch (Exception e) {
            return "Error removing collaborator: " + e.getMessage();
        }
    }
    //Export-related methods -----------------------------------------------------------------
    // Create an export configuration
    @PostMapping("/create")
    public @ResponseBody String createExportConfiguration(@RequestParam Integer familyTreeId,
                                                          @RequestParam String format,
                                                          @RequestParam boolean includePrivateData) {
        try {
            FamilyTree familyTree = familyTreeRepository.findById(familyTreeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));

            ExportConfiguration exportConfig = new ExportConfiguration();
            exportConfig.setFamilyTree(familyTree);
            exportConfig.setFormat(format);
            exportConfig.setIncludePrivateData(includePrivateData);

            exportConfigurationRepository.save(exportConfig);
            return "Export configuration created successfully.";
        } catch (Exception e) {
            return "Error creating export configuration: " + e.getMessage();
        }
    }

    // Read export configurations for a specific family tree
    @GetMapping("/getByFamilyTree")
    public @ResponseBody List<ExportConfiguration> getExportConfigurationsByFamilyTree(@RequestParam Integer familyTreeId) {
        return exportConfigurationRepository.findByFamilyTreeId(familyTreeId);
    }

    // Update an export configuration
    @PostMapping("/update")
    public @ResponseBody String updateExportConfiguration(@RequestParam Integer configId,
                                                          @RequestParam String format,
                                                          @RequestParam boolean includePrivateData) {
        try {
            ExportConfiguration exportConfig = exportConfigurationRepository.findById(configId)
                    .orElseThrow(() -> new RuntimeException("Export configuration not found"));

            exportConfig.setFormat(format);
            exportConfig.setIncludePrivateData(includePrivateData);
            exportConfigurationRepository.save(exportConfig);

            return "Export configuration updated successfully.";
        } catch (Exception e) {
            return "Error updating export configuration: " + e.getMessage();
        }
    }

    // Delete an export configuration
    @PostMapping("/delete")
    public @ResponseBody String deleteExportConfiguration(@RequestParam Integer configId) {
        try {
            exportConfigurationRepository.deleteById(configId);
            return "Export configuration deleted successfully.";
        } catch (Exception e) {
            return "Error deleting export configuration: " + e.getMessage();
        }
    }

    // Endpoint to trigger the export of the family tree
    @GetMapping("/exportFamilyTree")
    public @ResponseBody String exportFamilyTree(@RequestParam Integer familyTreeId,
                                                 @RequestParam Integer configId) {
        try {
            FamilyTree familyTree = familyTreeRepository.findById(familyTreeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));
            ExportConfiguration config = exportConfigurationRepository.findById(configId)
                    .orElseThrow(() -> new RuntimeException("Export configuration not found"));

            // Use the ExportService to generate the export data
            return exportService.exportFamilyTree(familyTree, config.getFormat(), config.isIncludePrivateData());
        } catch (Exception e) {
            return "Error exporting family tree: " + e.getMessage();
        }
    }
    //notification-related methods -----------------------------------------------------------------
    // Endpoint to retrieve all notifications for a specific user
    @GetMapping("/notifications/{userId}")
    public @ResponseBody List<Notification> getUserNotifications(@PathVariable Integer userId) {
        return notificationService.getUserNotifications(userId);
    }
    // Endpoint to manually create a notification for testing
    @PostMapping("/notifications/add")
    public @ResponseBody String addNotification(@RequestParam Integer userId,
                                                @RequestParam String message,
                                                @RequestParam String url,
                                                @RequestParam Integer treeId) {
        try {
            // get the user by ID
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Create a new notification
            notificationService.createNotification(user, message, url, treeId);
            return "Notification created successfully.";
        } catch (Exception e) {
            return "Error creating notification: " + e.getMessage();
        }
    }

    // Endpoint to delete a notification by ID for a specific user
    @DeleteMapping("/notifications/delete")
    public @ResponseBody String deleteNotification(@RequestParam Integer userId, @RequestParam Integer notificationId) {
        try {
            notificationService.deleteNotification(userId, notificationId);
            return "Notification deleted successfully.";
        } catch (Exception e) {
            return "Error deleting notification: " + e.getMessage();
        }
    }

    @PostMapping("/inviteCollaborator")
    public @ResponseBody String inviteCollaborator(@RequestParam Integer treeId,
                                                   @RequestParam String userEmail,
                                                   @RequestParam Role role) {
        try {
            // Fetch the FamilyTree and User
            FamilyTree familyTree = familyTreeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Family tree not found"));
            User user = userRepository.findByEmail(userEmail)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Check if the user is already invited or a collaborator
            Optional<Collaboration> existingCollaboration = collaborationRepository
                    .findByFamilyTreeIdAndUserId(treeId, user.getId());
            if (existingCollaboration.isPresent()) {
                Collaboration collaboration = existingCollaboration.get();
                if (collaboration.getStatus() == Status.Pending || collaboration.getStatus() == Status.Accepted) {
                    return "User is already invited or a collaborator.";
                }
            }

            // Create a new collaboration
            Collaboration collaboration = new Collaboration();
            collaboration.setFamilyTree(familyTree);
            collaboration.setUser(user);
            collaboration.setRole(role);
            collaboration.setStatus(Status.Pending);
            collaborationRepository.save(collaboration);

            // Send notification to the invited user
            notificationService.createNotification(
                    user,
                    "You have been invited to collaborate on the tree '" + familyTree.getTreeName() + "'.",
                    "/trees/" + treeId, treeId
            );

            return "Collaboration invitation sent successfully.";
        } catch (Exception e) {
            return "Error inviting collaborator: " + e.getMessage();
        }
    }

    //Merge Family Tree-related methods ------------------------------------------------------------
    //Request merge with another family tree
    @PostMapping("/requestMerge")
    public @ResponseBody String requestMerge(
            @RequestParam Integer requesterTreeId,
            @RequestParam Integer targetTreeId,
            @RequestParam Integer initiatorUserId) {
        return familyTreeService.requestMerge(requesterTreeId, targetTreeId, initiatorUserId);
    }


    //Accept merge request
    @PostMapping("/acceptMergeRequest")
    public @ResponseBody String acceptMergeRequest(@RequestParam Integer mergeRequestId) {
        return familyTreeService.acceptMergeRequest(mergeRequestId);
    }

    //Decline merge request
    @PostMapping("/declineMergeRequest")
    public @ResponseBody String declineMergeRequest(@RequestParam Integer mergeRequestId) {
        return familyTreeService.declineMergeRequest(mergeRequestId);
    }

    //Get merge requests for a specific tree
    @GetMapping("/getMergeRequests")
    public @ResponseBody List<MergeRequest> getMergeRequests(@RequestParam Integer treeId) {
        return mergeRequestRepository.findByTargetTree_Id(treeId);
    }

    //Get matching individuals
    @GetMapping("/getMatches")
    public @ResponseBody List<ConflictLog> getMatches(@RequestParam Integer treeId1, @RequestParam Integer treeId2) {
        return familyTreeService.getMatchingMembers(treeId1, treeId2);
    }

    //Confirm match matches two trees and adds conflicts to the table
    @PostMapping("/confirmMatch")
    public @ResponseBody String confirmMatch(
            @RequestParam Integer conflictId,
            @RequestParam boolean isSamePerson) {
        return familyTreeService.confirmMatch(conflictId, isSamePerson);
    }

    //Method to get conflicts by treeId and status ("Pending", "Accepted")
    @GetMapping("/getConflictsByStatus")
    public @ResponseBody List<ConflictLog> getConflictsByStatus(
            @RequestParam Integer treeId,
            @RequestParam String status) {
        return familyTreeService.getConflictsByTreeIdAndStatus(treeId, status);
    }

    //Finalize Merge - Final step to merge trees after conflicts are delt with
    @PostMapping("/finalizeMerge")
    public @ResponseBody FamilyTree finalizeMerge(@RequestParam Integer treeId1, @RequestParam Integer treeId2) {
        return familyTreeService.finalizeMerge(treeId1, treeId2);
    }

    // Suggested Edits-related methods -----------------------------------------------------------------
    // Endpoint to create a suggested edit
    @PostMapping("/suggestedEdits/create")
    public @ResponseBody String createSuggestedEdit(
            @RequestParam Integer memberId,
            @RequestParam Integer suggestedById,
            @RequestParam String fieldName,
            @RequestParam String oldValue,
            @RequestParam String newValue) {
        try {
            FamilyMember member = familyMemberRepository.findById(memberId)
                    .orElseThrow(() -> new RuntimeException("Family member not found"));
            User suggestedBy = userRepository.findById(suggestedById)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Create and save the suggested edit
            SuggestEdit edit = new SuggestEdit();
            edit.setFamilyMember(member);
            edit.setSuggestedBy(suggestedBy);
            edit.setFieldName(fieldName);
            edit.setOldValue(oldValue);
            edit.setNewValue(newValue);
            edit.setSuggestionStatus(SuggestionStatus.Pending);

            suggestedEditService.createSuggestedEdit(edit);
            return "Suggested Edit Created Successfully";
        } catch (Exception e) {
            return "Error creating suggested edit: " + e.getMessage();
        }
    }

    // Endpoint to update the status of a suggested edit (Accept or Decline)
    @PostMapping("/suggestedEdits/updateStatus")
    public @ResponseBody String updateEditStatus(@RequestParam Integer suggestionId,
                                                 @RequestParam SuggestionStatus status) {
        try {
            suggestedEditService.updateSuggestedEditStatus(suggestionId, status);
            return "Suggested Edit Status Updated";
        } catch (Exception e) {
            return "Error updating suggested edit status: " + e.getMessage();
        }
    }

    // Method to accept a suggested edit and apply the change
    @PostMapping("/suggestedEdits/accept")
    @Transactional
    public @ResponseBody String acceptSuggestedEdit(@RequestParam Integer suggestionId) {
        try {
            // Fetch the suggested edit
            SuggestEdit suggestedEdit = suggestEditRepository.findById(suggestionId)
                    .orElseThrow(() -> new RuntimeException("Suggested edit not found"));

            // Fetch the family member associated with the suggested edit
            FamilyMember familyMember = suggestedEdit.getFamilyMember();
            if (familyMember == null) {
                return "Error: No family member associated with this suggested edit.";
            }

            // Apply the suggested edit based on the fieldName

            switch (suggestedEdit.getFieldName()) {
                case "name":
                    familyMember.setName(suggestedEdit.getNewValue());
                    break;
                case "birthdate":
                    familyMember.setBirthdate(new SimpleDateFormat("yyyy-MM-dd").parse(suggestedEdit.getNewValue()));
                    break;
                case "deathdate":
                    familyMember.setDeathdate(new SimpleDateFormat("yyyy-MM-dd").parse(suggestedEdit.getNewValue()));
                    break;
                case "gender":
                    familyMember.setGender(Gender.valueOf(suggestedEdit.getNewValue()));
                    break;
                case "additionalInfo":
                    familyMember.setAdditionalInfo(suggestedEdit.getNewValue());
                    break;
                default:
                    return "Error: Unsupported field for suggested edit.";
            }

            // Save the updated family member
            familyMemberRepository.save(familyMember);

            // Mark the suggested edit as accepted
            suggestedEdit.setSuggestionStatus(SuggestionStatus.Accepted);
            suggestEditRepository.save(suggestedEdit);

            return "Suggested edit accepted and applied.";
        } catch (Exception e) {
            return "Error applying suggested edit: " + e.getMessage();
        }
    }

    // Method to decline a suggested edit (marks as declined)
    @PostMapping("/suggestedEdits/decline")
    @Transactional
    public @ResponseBody String declineSuggestedEdit(@RequestParam Integer suggestionId) {
        try {
            SuggestEdit edit = suggestEditRepository.findById(suggestionId)
                    .orElseThrow(() -> new RuntimeException("Suggested edit not found"));

            edit.setSuggestionStatus(SuggestionStatus.Denied);
            suggestEditRepository.save(edit);

            return "Suggested edit declined successfully.";
        } catch (Exception e) {
            return "Error declining suggested edit: " + e.getMessage();
        }
    }

    // Endpoint to get all suggested edits for a specific family tree
    @GetMapping("/suggestedEdits/review")
    public @ResponseBody List<SuggestEdit> reviewSuggestedEdits(@RequestParam Integer treeId) {
        return suggestEditRepository.findByFamilyMember_FamilyTree_Id(treeId);
    }

    // Method to get all suggested edits for a specific family member
    @GetMapping("/suggestedEdits/getByMember")
    public @ResponseBody List<SuggestEdit> getSuggestedEditsForMember(@RequestParam Integer memberId) {
        return suggestEditRepository.findByFamilyMember_MemberId(memberId);
    }

    // Method to get all suggested edits (for admin or review purposes)
    @GetMapping("/suggestedEdits/all")
    public @ResponseBody Iterable<SuggestEdit> getAllSuggestedEdits() {
        return suggestEditRepository.findAll();
    }



}
