package com.family_tree.familytree;

import java.io.IOException;
import java.util.Date;
import com.family_tree.enums.Gender;
import com.family_tree.enums.PrivacySetting;
import com.family_tree.enums.SuggestionStatus;
import com.family_tree.enums.RelationshipType;
import com.family_tree.enums.Role;
import com.family_tree.enums.Status;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

@Controller // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController {

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    @Autowired
    private FamilyTreeRepository familyTreeRepository;

    @Autowired
    private FamilyMemberRepository familyMemberRepository;

    @Autowired
    private SuggestEditRepository suggestEditRepository;

    @Autowired
    private RelationshipRepository relationshipRepository;

    @Autowired
    private AttachmentRepository attachmentRepository;

    @Autowired
    private CollaborationRepository collaborationRepository;

    // User-related methods
    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam String username,
                                            @RequestParam String emailAddress) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        User user = new User();
        user.setUsername(username);
        user.setEmail(emailAddress);
        userRepository.save(user);
        return "Saved";
    }

    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    // FamilyTree-related methods
    @PostMapping("/addFamilyTree")
    public @ResponseBody String addFamilyTree(@RequestParam String treeName,
                                              @RequestParam PrivacySetting privacySetting,
                                              @RequestParam Integer userId) {
        User owner = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        FamilyTree familyTree = new FamilyTree();
        familyTree.setTreeName(treeName);
        familyTree.setPrivacySetting(privacySetting);
        familyTree.setOwner(owner);

        familyTreeRepository.save(familyTree);
        return "Family Tree Saved";
    }

    @GetMapping("/allFamilyTrees")
    public @ResponseBody Iterable<FamilyTree> getAllFamilyTrees() {
        return familyTreeRepository.findAll();
    }

    //FamilyMember-related methods
    @PostMapping("/addFamilyMember")
    public @ResponseBody String addFamilyMember(@RequestParam String name,
                                                @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date birthdate,
                                                @RequestParam Gender gender,  // Gender is already of type Gender
                                                @RequestParam Integer userId,
                                                @RequestParam Integer treeId,
                                                @RequestParam Integer addedById,
                                                @RequestParam(required = false) String additionalInfo) {
        FamilyTree familyTree = familyTreeRepository.findById(treeId)
                .orElseThrow(() -> new RuntimeException("Family tree not found"));

        // Find the user who owns this family member
        User owner = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Owner not found"));

        User addedBy = userRepository.findById(addedById)
                .orElseThrow(() -> new RuntimeException("User not found"));

        FamilyMember familyMember = new FamilyMember();
        familyMember.setName(name);
        familyMember.setBirthdate(birthdate);
        familyMember.setGender(gender); // No need for valueOf() here
        familyMember.setFamilyTree(familyTree);
        familyMember.setAddedBy(addedBy);
        familyMember.setAdditionalInfo(additionalInfo);

        familyMemberRepository.save(familyMember);
        return "Family Member Saved";
    }

    //Method to retrieve all family members
    @GetMapping("/allFamilyMembers")
    public @ResponseBody Iterable<FamilyMember> getAllFamilyMembers() {
        return familyMemberRepository.findAll();
    }

    //SuggestEdit-related methods
    @PostMapping("/addSuggestedEdit")
    public @ResponseBody String addSuggestedEdit(@RequestParam Integer memberId,
                                                 @RequestParam Integer suggestedById,
                                                 @RequestParam String fieldName,
                                                 @RequestParam String oldValue,
                                                 @RequestParam String newValue) {
        FamilyMember member = familyMemberRepository.findById(memberId)
                .orElseThrow(() -> new RuntimeException("Family member not found"));

        User suggestedBy = userRepository.findById(suggestedById)
                .orElseThrow(() -> new RuntimeException("User not found"));

        SuggestEdit suggestedEdit = new SuggestEdit();
        suggestedEdit.setMember(member);
        suggestedEdit.setSuggestedBy(suggestedBy);
        suggestedEdit.setFieldName(fieldName);
        suggestedEdit.setOldValue(oldValue);
        suggestedEdit.setNewValue(newValue);
        suggestedEdit.setSuggestionStatus(SuggestionStatus.Pending);  // Default status

        suggestEditRepository.save(suggestedEdit);
        return "Suggested Edit Saved";
    }

    // Method to retrieve all suggested edits
    @GetMapping("/allSuggestedEdits")
    public @ResponseBody Iterable<SuggestEdit> getAllSuggestedEdits() {
        return suggestEditRepository.findAll();
    }

    // Relationship-related methods
    @PostMapping("/addRelationship")
    public @ResponseBody String addRelationship(@RequestParam Integer treeId,
                                                @RequestParam Integer member1Id,
                                                @RequestParam Integer member2Id,
                                                @RequestParam RelationshipType relationship) {
        FamilyTree familyTree = familyTreeRepository.findById(treeId)
                .orElseThrow(() -> new RuntimeException("Family tree not found"));

        FamilyMember member1 = familyMemberRepository.findById(member1Id)
                .orElseThrow(() -> new RuntimeException("Family member 1 not found"));

        FamilyMember member2 = familyMemberRepository.findById(member2Id)
                .orElseThrow(() -> new RuntimeException("Family member 2 not found"));

        Relationship rel = new Relationship();
        rel.setFamilyTree(familyTree);
        rel.setMember1(member1);
        rel.setMember2(member2);
        rel.setRelationship(relationship);

        relationshipRepository.save(rel);
        return "Relationship Saved";
    }

    @GetMapping("/allRelationships")
    public @ResponseBody Iterable<Relationship> getAllRelationships() {
        return relationshipRepository.findAll();
    }

    //Attachment-related methods
    @PostMapping("/addAttachment")
    public @ResponseBody String addAttachment(
            @RequestParam Integer memberId,
            @RequestParam String typeOfFile,
            @RequestParam MultipartFile fileData, // MultipartFile to handle binary data upload
            @RequestParam Integer uploadedById) {

        // Find the family member to whom this attachment will be associated
        FamilyMember member = familyMemberRepository.findById(memberId)
                .orElseThrow(() -> new RuntimeException("Family member not found"));

        // Find the user who uploaded this file
        User uploadedBy = userRepository.findById(uploadedById)
                .orElseThrow(() -> new RuntimeException("Uploader not found"));

        // Create a new attachment
        Attachment attachment = new Attachment();
        attachment.setMember(member);
        attachment.setTypeOfFile(typeOfFile);

        try {
            // Set the file data from the MultipartFile input
            attachment.setFileData(fileData.getBytes());
        } catch (IOException e) {
            return "Failed to read file data";
        }

        attachment.setUploadedBy(uploadedBy);

        // Save the attachment to the database
        attachmentRepository.save(attachment);
        return "Attachment Saved";
    }

    //Collaboration-related methods
    @PostMapping("/addCollaboration")
    public @ResponseBody String addCollaboration(@RequestParam Integer treeId,
                                                 @RequestParam Integer userId,
                                                 @RequestParam Role role,
                                                 @RequestParam Status status) {
        FamilyTree familyTree = familyTreeRepository.findById(treeId)
                .orElseThrow(() -> new RuntimeException("Family tree not found"));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Collaboration collaboration = new Collaboration();
        collaboration.setFamilyTree(familyTree);
        collaboration.setUser(user);
        collaboration.setRole(role);
        collaboration.setStatus(status);

        collaborationRepository.save(collaboration);
        return "Collaboration Saved";
    }

    @GetMapping("/allCollaborations")
    public @ResponseBody Iterable<Collaboration> getAllCollaborations() {
        return collaborationRepository.findAll();
    }

}
